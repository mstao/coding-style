# 数据库设计规范

针对目前常用的MySQL数据库，做出以下规范。

## 命名

|          | 规范                                                         | 示例                                                         | 描述                                          |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------------------------- |
| 数据库名 | 项目命名；项目缩写+有意义的英文单词组成；多个单词以下划线分割；全部为小写字母组成 |                                                              |                                               |
| 表名     | 固定前缀 + 模块命名；有意义的英文单词组成；多个单词以下划线分割；全部为小写字母组成；复杂业务场景下可以按照业务前缀进行业务域区分 | <code>t_auth_account</code><br><code>t_auth_resource</code>  | 固定前缀：<code>t_</code>                     |
| 字段名   | 实体属性名；有意义的英文单词组成；多个单词以下划线分割；全部为小写字母组成 | <code>name</code> <code>age</code> <code>user_id</code>      | 存在关联关系的字段，如外键：<code>a_id</code> |
| 索引     | 固定前缀 + 表名 + 字段名；需注意索引名长度限制；唯一索引增加`unique`标识 | <code>idx_authority_account_age</code>                       | 固定前缀：<code>idx_</code>                   |

## 数据格式

常用的数据类型：bigint、tinyint、int、decimal、datetime、timestamp、varchar。

*小数类型建议使用 decimal，不建议使用 float、double。*

## 基础字段

| 字段名      | 描述     | 类型      | 默认值                                 | 是否必选 | 
| ----------- | -------- | --------- | ------------------------------------ | ------   |
| id          | 主键     | bigint    | 自增或雪花算法（序列化时转为String）    | 是       |
| create_time | 插入时间 | timestamp | CURRENT_TIMESTAMP                     | 是       |
| update_time | 更新时间 | timestamp | CURRENT_TIMESTAMP                     | 是       |
| is_delete   | 逻辑删除 | tinyint   | 0                                     | 否       |
| version     | 版本号   | bigint    | 0                                     | 否       |

**逻辑删除应用场景**

用于逻辑删除，适合基础资料，各种单据主表。配置表，明细表等不需要删除标志

**版本号应用场景**

用于乐观锁并发控制，适合基础资料，各种单据主表等。单据的明细表不需要版本号。

## 表字段基本约束

- 全部小写命名，禁止出现大写
- 字段必须填写描述信息
- 字段均使用下划线分隔
- 字段禁止使用无意义缩写，使用完整名称代替，不要怕长
- 在命名表的列时，不要重复表的名称。例如，在名employe的表中避免使用名为employee_lastname的字段

## 表之间引用字段

一个表A需要存储另一个表B的字段，那么在A表中，需要明确B的字段所属，即命名规则为：`B_XX`

在单据中，比如需要存订单的单号和id，即当前表的订单相关字段命名：`order_bill_id`, `order_bill_no`

## 索引规约

### 命名规约

- 普通索引：idx_xx
- 唯一索引：idx_unique_xx

注意点：

1. 联合索引，注意越通用的，越靠前，比如仓库id，这个要放在第一位
2. 字段是枚举的，不需要建议索引，根据cardinality进行评估

### 唯一索引使用规约

凡是业务上有唯一约束的，必须要加上唯一索引。如果只有业务层代码处理唯一性，在并发情况下会出现问题。 

注意点：

1. 在MySQL中，唯一联合索引中如果有字段是可空的，当存入数据为`NULL` 时，唯一索引会失效，所以在新增数据时，可空字段必须默认为**空字符串**

### 表设计规约

（1）数据库表中的低频变更字段的写入，不能影响高频变更字段的写入，也就是说低频变更字段可以延迟或者批量写入，高频变更字段可以适度采用批量更新方式；

（2）读多，变更少的，非关键标示的字段，从业务主表中拆离，做成扩展表（并且可以考虑redis缓存等），减少读的IO以及加锁，影响主表数据的写入IO性能以及申请锁的等待；

（3）相同字段（表达的业务意义相同），在不同的表中数据类型必须一致（否则会不走索引），在不同的表中保持字段名称，数据长度等都要相同（否则出现一个表长度不够，无法写入等不一致的问题）；

## SQL处理规约

### 复杂SQL处理

尽量简化SQL。复杂拼装、组合逻辑放在代码中处理。

理由：

复杂数据库操作，比如大量连表，子查询，可以考虑将一个大的sql拆开，采用批量查询模式，在内存中进行组合，分组等操作，这样可以大大提高查询性能。
越简单的sql，我们去分析SQL查询计划时更易找到优化点，比如某个字段缺少索引等，更利于排查。

### 循环代码块中的数据库操作

建议不要在for循环中出现出现操作数据库相关逻辑，因为for循环的列表是由外部输入的，无法确切预知数据规模，可能造成操作响应超时等不可预知的问题。

### 需要某些字段`非空/空` 去数据库查询的逻辑，统统放在业务层去过滤，否则极易出bug

数据库表中的NULL 和 空字符串是两码事，如果表设计不统一，那么写的代码是非常容易出BUG的。

### 复杂的统计分析，或者数据报表，需要统一评审并严格进行优化，否则会引发mysql IO性能问题

正式环境，统计分析报表这类需求，不应该直接读取业务库，而是读从库。

### update语句，如果更新的行是多个，那么建议使用id批量更新，或者针对and条件添加索引，否则如果update后的条件命中多行，会造成“写锁等待”--》长事务问题，以及加锁范围过大，造成“范围锁”，其他并发操作可能会造成死锁或者长时间拿不到锁的超时问题

#### 如果数据存储需要分表，或者切片，必须要“动态考虑 数据的扩容和发展变化”，分表的方案要慎重，防止后续变更分表规则，带来的数据迁移和其他已经依赖 分表关联数据的复杂度

### 针对【库存】等敏感数据，必须保证 读的强一致性（是否永远只能从主库中读取，否则会有脏数据），比如是否可以从缓存读，缓存中数据是否和数据库同步

## 冗余设计规约

要分清楚场景，有些是属于快照，有些是属于冗余。

1.**快照场景**：交易场景大部分是数据快照，而不是冗余，用户下单时候的用户名、地址、商品名称、商品描述等，若采用关联，商品在下单后发生了更新的话再去关联查询就会导致和用户操作时的数据不一致，从而产生纠纷。

2.**冗余场景**：一般数据改动的可能性少，而查询多的场景会使用冗余，例如淘宝的店铺名称，淘宝商家中心会有这个字段，可能里面的商家论坛也有，再假设聚划算这种独立的大业务自己也存一份，再来个垂直频道电器城的后台管理也独立存一份，这种场景是由于对查询性能要求高产生的，所以必须要冗余，在业务的取舍上，肯定是对让用户更快看到信息，那么不可避免的是带来维护成本的增加，对于数据一致性问题，只要做到最终一致就可以了，分布式的CAP原则的实际应用基本都是通过牺牲数据一致性(C)来保证高可用(A)和高可靠(P)， 因为这种场景大部分都是可以接受短暂的数据不一致的，对业务的影响及其微小。

在微服务时代下，尽量避免过多的关联查询，将原本需要关联查询的业务拆分开来，通过REST接口来互相调用，在内存中进行组合分组，最终达到目的。

参考：

https://www.zhihu.com/question/50662784/answer/147731726

