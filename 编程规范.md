# 编程规范

## 项目模块划分

**对于公共模块：**

- 尽量减少外部依赖，比如lombok就无须依赖，重的依赖也不要放到该模块中
- 将项目中公共的组件，比如util包，基础类等抽象到公共模块中
- 涉及到项目公共配置，比如SpringBoot配置等，可以考虑抽出个公共业务模块

所以针对以上几点，可以大致划分为：

- common-base: 最基础的模块，仅包含util，基础类等业务无关组件，不要依赖数据库，web服务等中间件
- common-biz：基础业务模块，包含公共异常处理，公共配置（SpringBoot），日志追踪等业务相关的，此包也可以根据项目的大小和组件的规模再次拆分，或者单独抽出个项目单独维护



**对于业务模块**，比如基础信息模块，需要拆分两个子模块：api子模块和service子模块。

- api子模块：对外提供feign client接口，实体信息等。其他微服务模块通过引入该api模块与其交互。
- service子模块：模块内部逻辑实现。

## 数据库

### 索引规约

#### 命名规约

- 普通索引：idx_xx
- 唯一索引：idx_unique_xx

注意点：

1. 联合索引，注意越通用的，越靠前，比如仓库id，这个要放在第一位
2. 字段是枚举的，不需要建议索引，根据cardinality进行评估

#### 唯一索引使用规约

凡是业务上有唯一约束的，必须要加上唯一索引。如果只有业务层代码处理唯一性，在并发情况下会出现问题。

### 表设计规约

（1）数据库表中的低频变更字段的写入，不能影响高频变更字段的写入，也就是说低频变更字段可以延迟或者批量写入，高频变更字段可以适度采用批量更新方式；

（2）读多，变更少的，非关键标示的字段，从业务主表中拆离，做成扩展表（并且可以考虑redis缓存等），减少读的IO以及加锁，影响主表数据的写入IO性能以及申请锁的等待；

（3）相同字段（表达的业务意义相同），在不同的表中数据类型必须一致（否则会不走索引），在不同的表中保持字段名称，数据长度等都要相同（否则出现一个表长度不够，无法写入等不一致的问题）；

### SQL处理规约

#### 复杂SQL处理

尽量简化SQL。复杂拼装、组合逻辑放在代码中处理。

理由：

复杂数据库操作，比如大量连表，子查询，可以考虑将一个大的sql拆开，采用批量查询模式，在内存中进行组合，分组等操作，这样可以大大提高查询性能。
越简单的sql，我们去分析SQL查询计划时更易找到优化点，比如某个字段缺少索引等，更利于排查。

#### 循环代码块中的数据库操作

建议不要在for循环中出现出现操作数据库相关逻辑，因为for循环的列表是由外部输入的，无法确切预知数据规模，可能造成操作响应超时等不可预知的问题。

#### 需要某些字段`非空/空` 去数据库查询的逻辑，统统放在业务层去过滤，否则极易出bug

数据库表中的NULL 和 空字符串是两码事，如果表设计不统一，那么写的代码是非常容易出BUG的。

#### 复杂的统计分析，或者数据报表，需要统一评审并严格进行优化，否则会引发mysql IO性能问题

正式环境，统计分析报表这类需求，不应该直接读取业务库，而是读从库。

#### update语句，如果更新的行是多个，那么建议使用id批量更新，或者针对and条件添加索引，否则如果update后的条件命中多行，会造成“写锁等待”--》长事务问题，以及加锁范围过大，造成“范围锁”，其他并发操作可能会造成死锁或者长时间拿不到锁的超时问题

#### 如果数据存储需要分表，或者切片，必须要“动态考虑 数据的扩容和发展变化”，分表的方案要慎重，防止后续变更分表规则，带来的数据迁移和其他已经依赖 分表关联数据的复杂度

#### 针对【库存】等敏感数据，必须保证 读的强一致性（是否永远只能从主库中读取，否则会有脏数据），比如是否可以从缓存读，缓存中数据是否和数据库同步

### 冗余设计规约

要分清楚场景，有些是属于快照，有些是属于冗余。

1.**快照场景**：交易场景大部分是数据快照，而不是冗余，用户下单时候的用户名、地址、商品名称、商品描述等，若采用关联，商品在下单后发生了更新的话再去关联查询就会导致和用户操作时的数据不一致，从而产生纠纷。

2.**冗余场景**：一般数据改动的可能性少，而查询多的场景会使用冗余，例如淘宝的店铺名称，淘宝商家中心会有这个字段，可能里面的商家论坛也有，再假设聚划算这种独立的大业务自己也存一份，再来个垂直频道电器城的后台管理也独立存一份，这种场景是由于对查询性能要求高产生的，所以必须要冗余，在业务的取舍上，肯定是对让用户更快看到信息，那么不可避免的是带来维护成本的增加，对于数据一致性问题，只要做到最终一致就可以了，分布式的CAP原则的实际应用基本都是通过牺牲数据一致性(C)来保证高可用(A)和高可靠(P)， 因为这种场景大部分都是可以接受短暂的数据不一致的，对业务的影响及其微小。

在微服务时代下，尽量避免过多的关联查询，将原本需要关联查询的业务拆分开来，通过REST接口来互相调用，在内存中进行组合分组，最终达到目的。

参考：

https://www.zhihu.com/question/50662784/answer/147731726


## 编辑器和代码格式

### 一行代码不要超过idea默认的120字符

在idea中，如果一行代码字符数超过120，每次阅读代码都要拉滚动条，后续代码阅读十分困难，所以一行代码不要超过idea默认的120字符。

idea 的设置中，找到以下路径：Wrapping and Braces -> Keep when reformatting -> Ensure rigth margin is not exceeded ，将`Ensure rigth margin is not exceeded`勾选上，
当这个选择之后，ctrl  + alt + L  格式化代码的时候，就会自动换行。


### idea中代码不应该出现警告

作为代码的编写者，需要对写的每一行代码负责，当idea 对这一行代码出现了警告提示，不能视而不见，出现警告的原因可能有：

1. 逻辑有冗余，重复的代码写了好几遍
2. 实现不够简洁，简单的逻辑写的很复杂
3. 有些局部变量声明但未使用
4. 接口不写任何注释
5. 逻辑上出现错误
6. ......

在编写代码中，尽量减少警告的出现，理论上不应该出现警告。有警告的代码也不应该出现在生产环境上。



## 编码规约



### 编码风格

#### 代码中快速失败操作和参数校验

在一个方法里面，需要对参数进行校验，推荐使用`Assert.notNull` 相关来进行参数校验，抛出 `IllegalArgumentException`，避免空指针，如下

```java
public Result calcuateFaultRouteAll(String projectId) {
    Assert.notNull(projectId, "projectId 不能为空");
	
    String x = null;
    
    Preconditions.checkArgument(!StringUtils.isBlank(x), "x 不能为空");
}
```

对于函数内部的局部变量进行校验时，推荐使用guava 的 `Preconditions.checkArgument` 来进行校验，消除if else，快速失败，减少逻辑冗余。使代码更容易阅读，更简洁。

如果满足某一条件，才继续进行下一步业务，否则该业务终止。这类的代码，建议先判断不满足该条件，提前返回，而不要写一堆的if/else 。

```Java
public void f() {
	if (xxx) {
		return;
	}
	
	if (yyyy) {
		return;
	}
	
	// 做核心业务
}
```

#### 单个方法的总行数不要太长（阿里巴巴规范）

代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码
更加清晰；共性逻辑抽取成为共性方法，便于复用和维护。

例如导入Excel逻辑，大体上分为五步：

1. 解析excel文件
2. 将解析后的数据转为业务实体
3. 处理正常导入逻辑，在该过程中，会出现一些数据导入失败的情况，需要将记录下来（数据+错误信息），并且作为该步的返回值
4. 处理导入失败的数据，可以将导入失败的数据写入excel，并把错误信息也写入excel
5. 统计导入的情况，包括成功多少，失败多少，失败生成的链接下载地址是多少


上述这几步就是红花，至于每一步的具体实现，那么就需要封装起来，伪代码如下：

```java
public Result importExcel(data) {
	// 1. 解析excel文件
	Object sourceExcelData = readExcel(data);
	
	// 2. 将解析后的数据转为业务实体
	Object bizData = convertBiz(sourceExcelData);
	
	// 3. 处理正常导入逻辑
	Object errorData = handleNormal(bizData);
	
	// 4. 处理导入失败逻辑
	handleError(errorData);
    
    // 统计导入情况，返回结果
    return result;
}
```

### 基础编码规约

#### 严格避免空指针，任何代码不允许出现空指针的问题

空指针是编程和开发不规范导致，不养成好的习惯，无法写出健壮的代码，也无法提高技术。

#### 实体转换代码中，不能硬编码业务逻辑

利用mapstruct进行实体之间转换，不要在mapping注解中硬编码业务逻辑，风险太大，业务代码都要用手写Java代码来实现。也不能在 xxxDecorator中写业务代码。

特别注意的是，实体转换代码不能承载业务逻辑，如果由于特殊原因，换掉当前使用的转换框架，那么下沉到该部分的业务也要进行重写，是十分不合理的。

#### 实体转换推荐框架mapstruct，禁止业务代码中使用BeanUtils

mapstruct在编译器就生成了字节码（get/set）,在运行期是直接使用的，速度更快，性能比较高。


#### 业务代码禁止出现序列化反序列化代码

序列化反序列化操作需要读写流，性能比较慢，在业务代码中不应该出现此类操作。但在mq等需要序列化反序列操作时，要考虑选用的序列化反序列性能以及可能发生的问题。

#### 不能吞掉异常，业务处理内部如果需要try,catch，请必须保证finally必然会执行资源释放、补偿或处理，或者重新向上层抛出【自定义异常】

代码中任何地方不能直接catch完异常不处理了，如果有必要进行catch，那么就要记录日志，日志必须记录当前操作发生问题的详细信息，比如：**哪个业务，哪一步，发生了什么问题，原因是什么？**

```java
log.error("哪个业务，哪一步，发生了什么问题，原因是：{}"， e.getMessage, e);
```

#### 项目中涉及到文件流操作的，必须慎重评审方案，必须考虑到“存在哪里”，“文件如何清理”，以及操作文件的大小限定，以及该业务的访问频次

因为不经过优化的文件流操作，会造成 主机buffer/cache上升（写入内容过大，文件本身过大），jvm堆外内存泄露（netty或者nio文件操作框架等），jvm内存溢出（文件太大）；是否需要外部存储，比如阿里OSS等，防止对本身服务器造成的IO性能问题，导致服务jvm本身的性能和不稳定。

#### 内存中使用static变量，或者集合类型的如List,HashMap等及其子类，需要严格的业务分析和评审，如果非必要，不要使用jvm静态变量，最好放置于外部的中间件或者其他公共的缓冲区，防止内存溢出；如果必须使用，需要做好最大限定和监控预警

#### 不允许使用超大对象，分析业务场景，是否都是小对象，存活周期短，不要用大对象当成“缓冲区”或者接口交互的载体；

#### 关键信息或者数据，必须用线程安全的集合，比如ConcurrentHashMap等，并且变量本身需要用AutomicInteger等线程安全的对象进行读取和操作；

#### volitile和ThreadLocal的使用需要严格评审，保证使用的正确规范

#### 使用接口返回的List，Map等数据，必须校验是否为空（null 或者空集合），不能直接使用，防止因为接口返回null出现空指针的情况。

#### 在使用stream的Collectors的groupingBy时，不能出现数据为空的情况，否则会报错`element cannot be mapped to a null key`

如下代码：

```
details.stream().collect(Collectors.groupingBy(Detail::getPlatformType))
```
如果`getPlatformType`为空，那么该代码就会报错，要注意。

#### 尝试使用`handler`, `processor`来分解service，使代码逻辑更清晰

平时开发过程中，我们不可能一个service把一个复杂模块从头写到尾，相对的我们要有一定的抽象，将复杂逻辑抽象出来，用各种`handler`, `processor`, `algorithm`来抽象。下面谈下个人的理解：

- `handler`，比较倾向有选择的实现，比如一个操作，有好几种不同的处理方式，此时我们就可以用handler来封装各个不同的处理方式，通过工厂模式来调用
- `processor`，倾向于处理流程的某个节点，比如前置处理器，后置处理器（Spring用的特别多，参考：BeanPostProcessor）
- `algorithm`，倾向于算法实现，如果系统有一些关键的算法，可以用这个来体现
- `listener`，用来表示监听的逻辑实现，MQ的消费者实现一般用这个

### 接口规约

#### 接口必须有注释

接口不是给写代码的人看的，而是作为业务的抽象而不需要关心其具体实现。如果接口没有注释，代码阅读者和调用者对接口方法的作用不是十分明确，需要进去具体的实现来观察具体的实现逻辑，增加阅读负担，且易出错。

所以接口都必须加上注释，注释包含接口方法的实现逻辑，注意事项，返回值翻译等。如果有异常抛出，那么也要注明什么情况下会抛出异常。

#### 服务之间通过接口交互，禁止出现一个服务调其他业务的dao层代码

`封装`是开发的基本规范，服务应该保证内部逻辑的封装性，对外暴露接口，调用者不需要关心内部的实现。所以`禁止出现一个服务调其他业务的dao层代码`。

#### 查询接口参数仅传需要用到的数据，不能因为方便随便用其他封装好的实体来作为查询条件，保证查询明确性

比如查询参数仅需要一个仓库id，在接口的设计上却使用了一个`OperatorContext` 操作上下文来作为参数，仅需要其中的仓库id字段，这样的接口是要禁止的。

```java
正例：
query(Integer houseId, xxx)

反例：
query(OperatorContext optContext, xxxx)
```

#### 查询的接口，不允许出现业务异常，如果查询不到，返回空

下面是一个通过feign client 查询用户的例子：

```java
// 通过feign调用
User user = userClient.get(1).fetchData();

if (user == null) {
   // DO 
} else {
   // DO
}
```

如果`userClient.get(1)`方法 查不到 user的情况下 抛出以业务异常，调用者想知道返回的结果，就必须try catch，这样就会用try catch来做业务流转，严重违背编码规范（禁止使用try catch来做业务判断）。


#### 接口返回的实体，禁止出现DB层相关实体，需要使用VO, DTO等业务传输层对象

服务层与DB层是有分层概念的，DB层相关实体仅在服务层使用，禁止在接口层出现，否则违背分层思想。

#### 接口返回的实体，应该是最纯粹的结果实体，不要用Result等任何与业务无关的实体包裹，增加代码的复杂性，调用者也不能直接地观察到接口的返回数据

目前很多服务层（Dubbo接口层和服务接口层）接口代码返回值有用`AjaxResult`进行包裹，完全看不出接口的返回值是什么，导致代码超级混乱。这种应该是要完全禁止的，WMS代码中禁止出现。
接口的返回值禁止使用Object等这种业务无关的对象。

#### 接口的返回值，禁止使用Map

接口的返回值如果是map，且没有明确的注释下，调用者完全不知道map的key是什么，对于后续的维护者，更是不明所以，所以大部分接口不应该使用Map作为返回值。

对于一些特殊的业务，key都是同一类型的值，比如都是用户id等，如果有特殊需求，可以使用，但务必写好注释，写清楚key是什么，value是什么。

#### 接口的返回值实体需要有类说明

如果没有类注释说明，调用者可能还需要猜测这个实体是干什么的，当实体很多，搞清楚每个实体是干什么的，是一个很大的工作量，且是无用功。

#### 添加接口方法时，需要观察是否已经有了所需要的接口，不要上来就直接加

在添加接口方法时，很多人直接加，导致接口中重复功能的方法出现，这种不应该出现。

### 多线程规约

#### 多线程的编程模式需要严格把控，不同的业务，不允许用相同的 线程池，线程池必须保证合理的设定参数，不能造成无限制的线程池导致内存溢出；多线程的编码方案必须进行严格评审，保证线程不会死锁，以及，线程中的执行，异常不能被吞掉，没有处理方案

#### 不允许在多线程或者 子线程中调用@Tx方法，如果有，必须保证@Tx事务最后整体串行或者最后统一提交

[Spring事务在多线程下保证原子性 - SegmentFault 思否](https://segmentfault.com/a/1190000021732712)

#### @Async注解需要谨慎使用并设定不同的参数，必须保证不同业务用不同的线程池，防止由于默认线程数的阻塞，造成业务排队或者卡顿



### 事务规约

#### @Transactional注解约束

在需要使用事务的方法中，统一使用如下注解，禁止使用`@Transactional`注解

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Throwable.class)
public @interface Tx {
    // Do Nothing
}
```

理由：

- `@Transactional`注解默认在产生`RuntimeException`和`Error`才会回滚，而出现checked exceptions 不会回滚，最好定义一个统一的异常注解，指定事务发生了什么异常会回滚；
- 避免在某个地方擅自更改事务的传播属性，隔离级别，回滚机制，导致系统不一致，出问题难以排查。

#### 事务注解必须标注在业务服务层方法的第一个入口，否则事务不生效

该情况经常会发生在有一个抽象类，定义一个公共方法A，其内部引用了一个抽象方法B，子类需要重写父类的抽象方法B，如果每个子类的B上面加事务注解，那么其A方法的事务不会生效。

#### 【优化】必须把长事务切分成  短事务，减少锁冲突时间和可能性；并且，事务中，把查询类的方法提前单独执行，只在需要“变更数据”的Service方法上添加 @Tx 事务，不要让读的时间，占用长事务加锁的时间

将查询相关的操作放在事务之外，可以尽可能减少事务持有的时间，提高性能。


### 业务规约

#### 相同业务的代码放入同一个包（package）

比如波次的库存分配实现，需要将代码放入到一个包中，便于管理和阅读代码。

在service的实现层中，如果一个业务出现了两个及以上的类，必须要建立一个单独的包，否则代码太乱。

#### 同一个业务有不同业务逻辑，可以考虑使用工厂模式

一个场景：

比如上架提交，现在有`入库上架提交`和`内部单据上架提交`，两种具体实现不一样，但对外来说，都是上架提交操作。为了统一接口，我们对外可以暴露一个提交接口，在提交接口内部，根据上架类型去调不同的上架逻辑，此时可以采用工厂模式。伪代码如下：

**统一上架提交接口**：

```java
    /**
     * 上架提交
     *
     * @param upShelvesActionVO 上架数据
     * @param operatorContext   操作信息
     */
    void commit(UpShelvesActionVO upShelvesActionVO, OperatorContext operatorContext);
```

**提交实现**：

```java
    public void commit(UpShelvesActionVO upShelvesActionVO, OperatorContext operatorContext) {
        UpCommitTypeEnum upCommitType;
        if （xxx) {
            upCommitType = UpCommitTypeEnum.ENTRY;
        } else {
            upCommitType = UpCommitTypeEnum.INNER;
        }

        // 处理上架提交逻辑
        UpCommitProcessor commitProcessor = UpCommitProcessorFactory.getProcessor(upCommitType);
        commitProcessor.commit(upShelves, upShelvesActionVO, operatorContext);
    }
```

**上架提交处理器接口**：

```Java
public interface UpCommitProcessor {
    /**
     * 上架提交
     *
     * @param upShelves         上架单信息
     * @param upShelvesActionVO 提交信息
     * @param operatorContext   操作信息
     */
    void commit(WatUpShelves upShelves, UpShelvesActionVO upShelvesActionVO, OperatorContext operatorContext);

    /**
     * 获取上架提交类型
     *
     * @return 上架提交类型
     */
    UpCommitTypeEnum getType();
}
```

**上架处理器生成工厂**：

```java
@Component
public class UpCommitProcessorFactory implements ApplicationContextAware {
    private static Map<String, UpCommitProcessor> upCommitProcessorMap;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        Map<String, UpCommitProcessor> map = applicationContext.getBeansOfType(UpCommitProcessor.class);
        upCommitProcessorMap = Maps.newHashMap();
        for (String key : map.keySet()) {
            upCommitProcessorMap.put(map.get(key).getType().name(), map.get(key));
        }
    }

    public static UpCommitProcessor getProcessor(UpCommitTypeEnum upCommitType) {
        Assert.notNull(upCommitType, "upCommitType");

        return upCommitProcessorMap.get(upCommitType.name());
    }
}
```

这里有一个优化点，在工厂创建对象时，我们可以将各个的处理器交给spring进行管理，获取对象时，这样就不需要再每次处理时都创建。Spring的IOC就是避免应用运行期间，不停的创建对象，销毁对象。尽量减少gc的次数。

#### 用版本号的业务，如果有业务状态，务必在业务内部进行状态校验

对一个业务来说，状态尤为重要，在并发情况下，如果不校验业务状态，就会有可能导致一个业务数据被重复处理多次，出现数据回写重复等严重BUG。

步骤：

1. 先校验状态，状态不符合业务要求，进行报错
2. 状态校验通过后，再使用版本号更新状态及数据

#### 核心业务用乐观锁时，可以考虑使用乐观锁版本冲突失败重试机制

比如收货回写订单，出库数据回写订单，这类业务我们不希望版本号冲突频繁报错，用户体验不好。这时可以考虑使用重试机制，在版本号冲突时进行重试。根据业务情况评估`重试次数`和`每次重试间隔`，保证接口的完整响应时间不能过长。 

#### 任何业务都要保证逻辑的闭环，有起始，就要有结束，同时需要记录起始的时间，操作人，结束的时间，操作人。同时考虑业务异常情况。

在一个业务中，业务闭环是十分重要的，业务有始有终，操作有迹可寻，这样在发生问题时，才可以快速定位。



#### 任何业务的控制权，必须掌握在其自己的服务手中，不允许将其控制权交给其他业务控制，业务与业务之间，必须通过接口进行交互

比如订单业务，会有收货，数据上架等子业务，这些子业务想要与订单业务交互，比如想回写收货数据，那么必须调订单的收货回写接口，在订单的收货回写接口内部进行订单的状态转换，数据变更逻辑，严禁直接暴露类似`updateState(OrderState state)`这种接口，而是用`receive(ReceiveData data)`这种明确的接口，否则直接会影响订单的业务流，代码逻辑也不清晰。

#### 所有的方法设计，必须考虑【超时时间】，以及【超时处理方案】，否则如果一旦某个业务故障，所有调用“故障业务”的线程都将阻塞，等待到超时，服务的各种线程池将会最终耗尽，造成【雪崩】，所有服务最后都会被拖垮



#### 业务与业务之间进行交互，如果彼此之间没有强依赖，结合业务场景，采用异步模式，比如使用MQ，尽量减少一个业务流程的复杂度，提高响应速度

比如订单收货上架与回传OMS业务，收货上架  与 回传OMS这两个业务，收货上架不需要等待回传oms后才算完成。

#### 上游下发过来的单据，存到wms系统都不要留delete_type，且必须加唯一索引

这样做是为了在数据库层间加唯一索引，保证同一个单子，wms有且仅有一单。

#### 涉及到 配置相关的表，也不要加delete_type，直接采用真删，数据库必须加唯一索引

因为这种大部分都会批量查，然后转为map处理，如果有两个key一样的，java会报错。

### RPC规约

#### 所有dubbo交互的vo，不能过大（否则影响dubbo序列化和反序列化效率），返回前端的vo，只返回必要字段（减少网络传输）

涉及到序列化反序列化操作，尽量返回有用的字段

#### dubbo中读方法应当重试，写方法或者变更方法必须取消retry，防止接口超时重试等，另外接口要从编码方式上保证幂等性；



### 中间件规约

#### 所有新中间件的引入，必须满足集群或者主备高可用，并且能满足性能扩展；另外，所有中间件必须有完备的监控预警方案和灾难处理方案

如果要引入中间件，那么必须需要完成相关文档，比如使用方式，集群方案，对现有架构的影响等等，经过评估以后再定是否采用。

#### 用分布式锁（悲观锁）时，先考虑清楚业务上是不是一定要用，是不是可以乐观锁+状态控制 解决问题，不要上来就用

大部分业务用乐观锁+状态控制就可以保证数据的完整性。如果冲突几率非常大用悲观，小就用乐观。需要业务评估。注意使用分布式悲观锁时要设置超时时间。

#### 悲观锁的使用，需要进行评审，从前端--》后端--》数据库 等层面综合考虑锁的粒度（从哪个数据维度加锁），锁的影响范围（什么类、什么方法等），锁的时间（评估平均事务时长），以及锁超时设定（锁被占用的最大时间设定，到时间检测业务是否执行完毕，是否需要强行释放锁），超时后的处理方案（是否重试、是否抛弃）等；不能让悲观锁无限制锁住，导致业务停滞

#### redis的key必须带项目名称，防止多项目冲突，比如wms_inner.userid，redis不能有过长的key和过大的value（一个很大的json字符串），不能有很长的hset或者队列

#### mq消息体，不能有过大的vo对象，这会影响高并发情况下mq存储的性能（IO压力大）和mq的消费效率（消费者需要网络传输消息体，并且需要反序列化）

只存放关键数据id等，消费端可以根据关键数据从数据库或者缓存加载。

#### 定时任务，不能用while(true)方式空转，会引起cpu消耗，应当适当sleep(定义一个合适的间隔)；定时任务必须人工错开高并发（不同的业务分别在不同的“时间间隔”执行，操作相同数据表的话，尽量错开时间，防止造成“表锁”或者“行锁”；

#### 执行频率比较高的定时任务读取数据时，大表不能出现全表扫描，如果需要查询数据，必须使用分页

有些定时任务执行频率很高，比如2分钟执行一次，每次读取一定量的数据，处理反而比较快，避免出现全表扫描的情况发生。如果一次读取数据过多，有可能出现oom的情况。

#### 在集群中，如果某一定时任务采用抢占式执行，那么必须保证同一时刻最多有一个该任务正在执行，否则会发生严重的业务问题。（回传数据重复等大量问题。）

有些任务执行具有唯一性，即使在一个集群中，也要保证该逻辑的正确性。

#### 高频的业务场景，不能用httpclient短连接，需要用httpclient连接池进行操作，防止连接泄露和大量tcp端口未释放对服务器和客户端的影响

对于连接来说，首先要考虑是否有池化的支持，如果有的话，首先考虑池化的方法。

#### 如果有业务代码直接强依赖 redis缓存，那么必须要有 redis数据回填方案（数据高可用），如果redis中数据丢失，可以从数据库查询--》然后回填redis；业务代码依赖redis的地方，需要统一考虑服务降级（如果redis不可用，业务依然可以继续执行）来保证功能高可用

#### Redis 批量操作使用建议

性能对比：multiSet() > pipeline管道 > 普通for循环set

优缺点：
- multiSet() ：不支持设置过期时间，但性能最高，对于不需要设置过期时间的，直接使用这个
- pipeline管道：扩展性强，可以支持设置失效时间，性能低于multiSet() 。每次管道里命令个数太多的话，也会造成客户端响应时间变久，网络传输阻塞。最好还是根据业务情况，将大的pipeline拆分成多个小的pipeline来执行
- 普通for循环set：性能最差，生产环境严禁使用该方式

使用方式：

**multiSet()**

```java
redisTemplate.opsForValue().multiSet(source);
```

**pipeline管道**

```java
 public void batchSetOrExpire(Map<String, String> map, Long seconds) {
        RedisSerializer<String> serializer = stringRedisTemplate.getStringSerializer();
        stringRedisTemplate.executePipelined(new RedisCallback<String>() {
            @Override
            public String doInRedis(RedisConnection connection) throws DataAccessException {
                map.forEach((key, value) -> {
                    connection.set(serializer.serialize(key), serializer.serialize(value), Expiration.seconds(seconds), RedisStringCommands.SetOption.UPSERT);
                });
                return null;
            }
        }, serializer);
    }
```

参考：

- https://blog.csdn.net/weixin_41677422/article/details/108626587
- https://www.cnblogs.com/dobal/p/12039835.html


